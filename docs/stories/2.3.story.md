# Story 2.3: Optional Photo Capture

## Status

Approved

## Story

**As a** user,  
**I want** to take a photo of my parking spot,  
**so that** I have a visual reminder (especially useful in garages).

## Acceptance Criteria

1. Confirmation screen shows "Add Photo" option
2. Tapping opens camera using getUserMedia API (not native camera app)
3. Photo is captured directly in browser, not saved to device gallery
4. Photo is compressed client-side to ≤200KB using Canvas API
5. EXIF metadata is stripped from photo before processing
6. Photo is uploaded to Cloudflare R2 with signed URL
7. Photo URL is saved with the spot record
8. Upload completes in ≤3 seconds on 4G; shows progress indicator
9. If camera permission denied, shows "Upload from Gallery" fallback

## Tasks / Subtasks

- [ ] **Task 1: Create Camera Capture Hook** (AC: 2, 3)
  - [ ] Create `apps/web/src/hooks/useCamera/useCamera.ts`
  - [ ] Create `apps/web/src/hooks/useCamera/types.ts`
  - [ ] Implement `startCamera()` - request getUserMedia
  - [ ] Implement `capturePhoto()` - capture frame to canvas
  - [ ] Implement `stopCamera()` - cleanup stream
  - [ ] Handle camera permission states
  - [ ] Prefer back camera on mobile (`facingMode: 'environment'`)
  - [ ] Write unit tests

- [ ] **Task 2: Create Image Processing Service** (AC: 4, 5)
  - [ ] Create `apps/web/src/services/image/imageProcessor.service.ts`
  - [ ] Create `apps/web/src/services/image/types.ts`
  - [ ] Implement `compressImage(blob, maxSizeKB)` - resize and compress
  - [ ] Implement `stripExifData(blob)` - remove metadata
  - [ ] Use Canvas API for compression
  - [ ] Target ≤200KB output
  - [ ] Maintain aspect ratio
  - [ ] Return compressed blob
  - [ ] Write unit tests

- [ ] **Task 3: Backend - Photo Upload Endpoint** (AC: 6)
  - [ ] Create `apps/api/src/routes/photos/photos.routes.ts`
  - [ ] Create `apps/api/src/routes/photos/photos.service.ts`
  - [ ] Create `apps/api/src/routes/photos/types.ts`
  - [ ] Add `POST /v1/photos/upload-url` - generate signed upload URL
  - [ ] Return pre-signed URL and photo ID
  - [ ] Require authentication
  - [ ] Write integration tests

- [ ] **Task 4: Cloudflare R2 Service** (AC: 6)
  - [ ] Create `apps/api/src/services/r2/r2.service.ts`
  - [ ] Create `apps/api/src/services/r2/types.ts`
  - [ ] Implement `generateUploadUrl(key)` - signed PUT URL
  - [ ] Implement `generateDownloadUrl(key)` - signed GET URL (15min expiry)
  - [ ] Implement `deleteObject(key)` - cleanup
  - [ ] Configure bucket name from env
  - [ ] Write unit tests with mocked R2

- [ ] **Task 5: Create Camera Capture UI** (AC: 1, 2, 3)
  - [ ] Create `apps/web/src/components/camera/CameraCapture.tsx`
  - [ ] Create `apps/web/src/components/camera/types.ts`
  - [ ] Display live camera preview
  - [ ] Add capture button (shutter)
  - [ ] Add close/cancel button
  - [ ] Add flip camera button (front/back)
  - [ ] Fullscreen overlay on mobile
  - [ ] Handle portrait/landscape orientation

- [ ] **Task 6: Create Photo Upload Hook** (AC: 6, 7, 8)
  - [ ] Create `apps/web/src/hooks/usePhotoUpload/usePhotoUpload.ts`
  - [ ] Create `apps/web/src/hooks/usePhotoUpload/types.ts`
  - [ ] Implement `uploadPhoto(blob)`:
    1. Request signed URL from API
    2. Upload to R2 via signed URL
    3. Return final photo URL
  - [ ] Track upload progress
  - [ ] Handle upload errors
  - [ ] Write unit tests

- [ ] **Task 7: Integrate into Confirmation Screen** (AC: 1, 7)
  - [ ] Add camera capture trigger to SpotActions
  - [ ] Open CameraCapture component on click
  - [ ] After capture: compress → upload → update spot (reuse PATCH from Story 2.5)
  - [ ] Show photo thumbnail after upload
  - [ ] Allow retake/delete photo

- [ ] **Task 8: Upload Progress Indicator** (AC: 8)
  - [ ] Create `apps/web/src/components/ui/UploadProgress.tsx`
  - [ ] Show progress bar during upload
  - [ ] Show success checkmark when complete
  - [ ] Show error state with retry option
  - [ ] 3-second target with visual feedback

- [ ] **Task 9: Camera Permission Denied Fallback** (AC: 9)
  - [ ] Detect permission denied state
  - [ ] Show "Upload from Gallery" button
  - [ ] Link to Story 2.4 implementation
  - [ ] Explain why camera is useful

- [ ] **Task 10: Guest Mode Photo Handling**
  - [ ] For guests: store photo as base64 in IndexedDB
  - [ ] Or: upload to R2 anonymously (with cleanup policy)
  - [ ] Decision: Use IndexedDB for true offline capability
  - [ ] Compress to smaller size for IndexedDB (≤100KB)

- [ ] **Task 11: Testing & Documentation**
  - [ ] Test camera capture on iOS Safari
  - [ ] Test camera capture on Android Chrome
  - [ ] Test compression output size
  - [ ] Test EXIF stripping
  - [ ] Test R2 upload end-to-end
  - [ ] Write Playwright E2E tests (mock camera)

## Dev Notes

### Architecture References

- [architecture-frontend/9-external-services.md](../architecture-frontend/9-external-services.md) - Camera API
- [architecture-backend/9-external-services.md](../architecture-backend/9-external-services.md) - R2 service
- [architecture/5-api-specification.md](../architecture/5-api-specification.md) - Photo endpoints

### Camera Capture Implementation

```typescript
// hooks/useCamera/useCamera.ts
export function useCamera() {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [stream, setStream] = useState<MediaStream | null>(null);
  const [permissionState, setPermissionState] = useState<PermissionState>('prompt');

  const startCamera = async (facingMode: 'user' | 'environment' = 'environment') => {
    try {
      const mediaStream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode,
          width: { ideal: 1280 },
          height: { ideal: 720 },
        },
        audio: false,
      });

      setStream(mediaStream);
      if (videoRef.current) {
        videoRef.current.srcObject = mediaStream;
      }
      setPermissionState('granted');
      return mediaStream;
    } catch (error) {
      if ((error as DOMException).name === 'NotAllowedError') {
        setPermissionState('denied');
      }
      throw error;
    }
  };

  const capturePhoto = (): Blob => {
    const video = videoRef.current;
    if (!video) throw new Error('Video not ready');

    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    const ctx = canvas.getContext('2d');
    ctx?.drawImage(video, 0, 0);

    return new Promise((resolve) => {
      canvas.toBlob((blob) => resolve(blob!), 'image/jpeg', 0.8);
    });
  };

  const stopCamera = () => {
    stream?.getTracks().forEach((track) => track.stop());
    setStream(null);
  };

  return { videoRef, startCamera, capturePhoto, stopCamera, permissionState };
}
```

### Image Compression

```typescript
// services/image/imageProcessor.service.ts
const MAX_SIZE_KB = 200;
const MAX_DIMENSION = 1200;

export const imageProcessor = {
  compressImage: async (blob: Blob): Promise<Blob> => {
    const img = await createImageBitmap(blob);

    // Calculate new dimensions
    let { width, height } = img;
    if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
      const ratio = Math.min(MAX_DIMENSION / width, MAX_DIMENSION / height);
      width *= ratio;
      height *= ratio;
    }

    // Draw to canvas
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d')!;
    ctx.drawImage(img, 0, 0, width, height);

    // Compress with quality reduction until under size limit
    let quality = 0.8;
    let result: Blob;

    do {
      result = await new Promise<Blob>((resolve) => {
        canvas.toBlob((b) => resolve(b!), 'image/jpeg', quality);
      });
      quality -= 0.1;
    } while (result.size > MAX_SIZE_KB * 1024 && quality > 0.1);

    return result;
  },

  stripExifData: async (blob: Blob): Promise<Blob> => {
    // Re-encoding through canvas automatically strips EXIF
    const img = await createImageBitmap(blob);
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d')!;
    ctx.drawImage(img, 0, 0);

    return new Promise((resolve) => {
      canvas.toBlob((b) => resolve(b!), 'image/jpeg', 1.0);
    });
  },
};
```

### R2 Signed URL Generation

```typescript
// services/r2/r2.service.ts
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

const r2Client = new S3Client({
  region: 'auto',
  endpoint: env.R2_ENDPOINT,
  credentials: {
    accessKeyId: env.R2_ACCESS_KEY_ID,
    secretAccessKey: env.R2_SECRET_ACCESS_KEY,
  },
});

export const r2Service = {
  generateUploadUrl: async (key: string): Promise<string> => {
    const command = new PutObjectCommand({
      Bucket: env.R2_BUCKET_NAME,
      Key: key,
      ContentType: 'image/jpeg',
    });

    return getSignedUrl(r2Client, command, { expiresIn: 300 }); // 5 min
  },

  generateDownloadUrl: async (key: string): Promise<string> => {
    const command = new GetObjectCommand({
      Bucket: env.R2_BUCKET_NAME,
      Key: key,
    });

    return getSignedUrl(r2Client, command, { expiresIn: 900 }); // 15 min
  },
};
```

### Photo Upload Flow

```
┌────────────┐     ┌────────────┐     ┌────────────┐     ┌────────────┐
│   Camera   │     │ Processor  │     │    API     │     │     R2     │
└─────┬──────┘     └─────┬──────┘     └─────┬──────┘     └─────┬──────┘
      │                  │                  │                  │
      │ Capture          │                  │                  │
      │─────────────────>│                  │                  │
      │                  │                  │                  │
      │                  │ Compress/Strip   │                  │
      │                  │────────>         │                  │
      │                  │                  │                  │
      │                  │ Get Upload URL   │                  │
      │                  │─────────────────>│                  │
      │                  │                  │                  │
      │                  │ Signed URL       │                  │
      │                  │<─────────────────│                  │
      │                  │                  │                  │
      │                  │ PUT blob to R2   │                  │
      │                  │─────────────────────────────────────>│
      │                  │                  │                  │
      │                  │ Success          │                  │
      │                  │<─────────────────────────────────────│
```

### Environment Variables

```bash
# Cloudflare R2
R2_ENDPOINT=https://<account_id>.r2.cloudflarestorage.com
R2_ACCESS_KEY_ID=<access_key>
R2_SECRET_ACCESS_KEY=<secret_key>
R2_BUCKET_NAME=wdip-photos
```

### File Locations

**New Backend Files:**

- `apps/api/src/routes/photos/photos.routes.ts`
- `apps/api/src/routes/photos/photos.service.ts`
- `apps/api/src/routes/photos/types.ts`
- `apps/api/src/services/r2/r2.service.ts`
- `apps/api/src/services/r2/types.ts`

**New Frontend Files:**

- `apps/web/src/hooks/useCamera/useCamera.ts`
- `apps/web/src/hooks/useCamera/types.ts`
- `apps/web/src/hooks/usePhotoUpload/usePhotoUpload.ts`
- `apps/web/src/hooks/usePhotoUpload/types.ts`
- `apps/web/src/services/image/imageProcessor.service.ts`
- `apps/web/src/services/image/types.ts`
- `apps/web/src/components/camera/CameraCapture.tsx`
- `apps/web/src/components/camera/types.ts`
- `apps/web/src/components/ui/UploadProgress.tsx`

### Testing Coverage

- useCamera: 90%
- imageProcessor: 100%
- r2Service: 100%
- usePhotoUpload: 95%
- CameraCapture: 85%

## Change Log

| Date       | Version | Description            | Author |
| ---------- | ------- | ---------------------- | ------ |
| 2026-01-15 | 1.0     | Initial story creation | PO     |
