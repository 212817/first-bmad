# Story 2.8: Reverse Geocoding for Address Display

## Status

Approved

## Story

**As a** user,  
**I want** to see a human-readable address for my saved spot,  
**so that** I can understand where I parked without reading coordinates.

## Acceptance Criteria

1. After saving a spot with GPS coordinates, fetch address from OpenCage API
2. Cache the geocoded address in the spot record
3. Display address on confirmation screen, spot detail, and history
4. If geocoding fails or quota exceeded, fall back to displaying coordinates
5. Geocoding happens asynchronously - don't block the save flow
6. Handle rate limits gracefully (queue, retry, or skip)

## Tasks / Subtasks

- [ ] **Task 1: Extend Geocoding Service for Reverse** (AC: 1)
  - [ ] Update `apps/api/src/services/geocoding/geocoding.service.ts`
  - [ ] Implement `reverseGeocode(lat, lng)` - coords to address
  - [ ] Parse OpenCage response for formatted address
  - [ ] Extract useful components (street, city)
  - [ ] Write unit tests

- [ ] **Task 2: Extend Geocache for Reverse Lookups** (AC: 2)
  - [ ] Add index on `lat`, `lng` to geocache table
  - [ ] Or create separate `reverse_geocache` table
  - [ ] Implement `findByCoords(lat, lng, precision)` - fuzzy match
  - [ ] Cache reverse results same as forward
  - [ ] Write unit tests

- [ ] **Task 3: Async Reverse Geocoding on Spot Save** (AC: 5)
  - [ ] After spot created, trigger reverse geocode (async)
  - [ ] Use job queue or fire-and-forget
  - [ ] Update spot record with address when complete
  - [ ] Don't fail spot save if geocoding fails

- [ ] **Task 4: Create Reverse Geocode Endpoint** (AC: 1)
  - [ ] Add `POST /v1/reverse-geocode` endpoint
  - [ ] Accept `{ lat, lng }`
  - [ ] Return `{ address, formattedAddress }`
  - [ ] Check cache first
  - [ ] Write integration tests

- [ ] **Task 5: Frontend - Display Address** (AC: 3)
  - [ ] Update SpotDetailCard to prioritize address
  - [ ] Show coordinates as fallback/secondary
  - [ ] Format: "Near [street], [city]"
  - [ ] Loading state while address fetches

- [ ] **Task 6: Frontend - Async Address Fetch** (AC: 3, 5)
  - [ ] After spot save, poll for address or use websocket
  - [ ] Or: fetch address on confirmation screen load
  - [ ] Update UI when address available
  - [ ] Don't block navigation

- [ ] **Task 7: History View Address Display** (AC: 3)
  - [ ] Show address in spot list items
  - [ ] Truncate long addresses
  - [ ] Format for quick scanning

- [ ] **Task 8: Coordinate Fallback Display** (AC: 4)
  - [ ] When no address: show "40.7128째N, 74.0060째W"
  - [ ] Format coordinates nicely
  - [ ] Consider showing "Unknown location" for context

- [ ] **Task 9: Rate Limit Handling** (AC: 6)
  - [ ] Track daily API usage
  - [ ] Queue requests when near limit
  - [ ] Skip non-critical reverse geocodes
  - [ ] Log when quota exceeded

- [ ] **Task 10: Guest Mode Reverse Geocoding**
  - [ ] Skip server geocoding for guests
  - [ ] Use browser-side or skip entirely
  - [ ] Display coordinates only for guests
  - [ ] Document limitation

- [ ] **Task 11: Testing & Documentation**
  - [ ] Test reverse geocoding accuracy
  - [ ] Test cache hit/miss
  - [ ] Test async flow doesn't block
  - [ ] Test coordinate fallback
  - [ ] Write Playwright E2E tests

## Dev Notes

### Architecture References

- Builds on Story 2.6 geocoding infrastructure
- [architecture-backend/9-external-services.md](../architecture-backend/9-external-services.md) - OpenCage

### OpenCage Reverse Geocoding

```
GET https://api.opencagedata.com/geocode/v1/json?q=LAT+LNG&key=API_KEY
```

Same endpoint as forward geocoding - just pass coords instead of address.

### Reverse Geocoding Service

```typescript
// services/geocoding/geocoding.service.ts (extend)
export const geocodingService = {
  // ... existing geocodeAddress

  reverseGeocode: async (lat: number, lng: number): Promise<ReverseGeocodingResult | null> => {
    // Check cache (with precision tolerance)
    const cached = await geocacheRepository.findByCoords(lat, lng, 0.0001);
    if (cached) {
      return cached;
    }

    // Call OpenCage
    const url = new URL(OPENCAGE_URL);
    url.searchParams.set('q', `${lat}+${lng}`);
    url.searchParams.set('key', env.OPENCAGE_API_KEY);
    url.searchParams.set('limit', '1');

    const response = await fetch(url);
    const data = await response.json();

    if (data.results?.length > 0) {
      const result = data.results[0];
      const address = formatAddress(result.components);

      // Cache result
      await geocacheRepository.createReverse({
        lat,
        lng,
        address,
        formattedAddress: result.formatted,
      });

      return { address, formattedAddress: result.formatted };
    }

    return null;
  },
};

// Format address for display
function formatAddress(components: OpenCageComponents): string {
  const parts = [];

  if (components.road) parts.push(components.road);
  if (components.neighbourhood) parts.push(components.neighbourhood);
  if (components.suburb) parts.push(components.suburb);
  if (components.city || components.town) parts.push(components.city || components.town);

  // Return first 2-3 meaningful parts
  return parts.slice(0, 3).join(', ');
}
```

### Async Geocoding After Save

```typescript
// routes/spots/spots.service.ts
export const spotsService = {
  createSpot: async (userId: string, data: CreateSpotDto): Promise<Spot> => {
    // Save spot immediately
    const spot = await spotRepository.create(userId, data);

    // Trigger async reverse geocoding (fire-and-forget)
    if (data.lat && data.lng) {
      geocodingService
        .reverseGeocode(data.lat, data.lng)
        .then(async (result) => {
          if (result) {
            await spotRepository.update(spot.id, { address: result.address });
          }
        })
        .catch((error) => {
          console.error('Reverse geocoding failed:', error);
          // Don't throw - spot already saved
        });
    }

    return spot;
  },
};
```

### Frontend Address Fetching

```typescript
// On confirmation screen
useEffect(() => {
  if (spot && !spot.address && spot.lat && spot.lng) {
    // Poll for address update or fetch directly
    const fetchAddress = async () => {
      const response = await fetch('/api/v1/reverse-geocode', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ lat: spot.lat, lng: spot.lng }),
      });

      if (response.ok) {
        const { address } = await response.json();
        setDisplayAddress(address);
      }
    };

    // Small delay to let async backend complete first
    setTimeout(fetchAddress, 1000);
  }
}, [spot]);
```

### Address Display Component

```tsx
// components/spot/SpotAddress.tsx
interface SpotAddressProps {
  spot: Spot;
}

export function SpotAddress({ spot }: SpotAddressProps) {
  if (spot.address) {
    return <div className="text-lg font-medium">Near {spot.address}</div>;
  }

  if (spot.lat && spot.lng) {
    return <div className="text-gray-600">{formatCoordinates(spot.lat, spot.lng)}</div>;
  }

  return <div className="text-gray-400 italic">Location not available</div>;
}

function formatCoordinates(lat: number, lng: number): string {
  const latDir = lat >= 0 ? 'N' : 'S';
  const lngDir = lng >= 0 ? 'E' : 'W';
  return `${Math.abs(lat).toFixed(4)}째${latDir}, ${Math.abs(lng).toFixed(4)}째${lngDir}`;
}
```

### Coordinate Precision for Cache

```typescript
// Round coordinates for cache lookup (about 11m precision)
const roundCoord = (coord: number, precision = 4): number => {
  return Math.round(coord * Math.pow(10, precision)) / Math.pow(10, precision);
};

// Cache lookup with tolerance
findByCoords: async (lat: number, lng: number, tolerance = 0.0001) => {
  const roundedLat = roundCoord(lat);
  const roundedLng = roundCoord(lng);

  return db
    .select()
    .from(geocache)
    .where(
      and(
        between(geocache.lat, roundedLat - tolerance, roundedLat + tolerance),
        between(geocache.lng, roundedLng - tolerance, roundedLng + tolerance)
      )
    )
    .limit(1);
};
```

### Rate Limit Tracking

```typescript
// Simple in-memory counter (reset daily)
let dailyApiCalls = 0;
const DAILY_LIMIT = 2400; // Leave buffer from 2500

const checkQuota = (): boolean => {
  if (dailyApiCalls >= DAILY_LIMIT) {
    console.warn('OpenCage daily quota exceeded');
    return false;
  }
  dailyApiCalls++;
  return true;
};

// Reset at midnight UTC
const resetQuotaDaily = () => {
  setInterval(() => {
    const now = new Date();
    if (now.getUTCHours() === 0 && now.getUTCMinutes() === 0) {
      dailyApiCalls = 0;
    }
  }, 60000); // Check every minute
};
```

### File Locations

**Modified Backend Files:**

- `apps/api/src/services/geocoding/geocoding.service.ts` - add reverseGeocode
- `apps/api/src/repositories/geocache.repository.ts` - add findByCoords
- `apps/api/src/routes/spots/spots.service.ts` - async geocoding on save

**New Backend Files:**

- `apps/api/src/routes/geocode/reverse.routes.ts` (or combine with forward)

**New Frontend Files:**

- `apps/web/src/components/spot/SpotAddress.tsx`

**Modified Frontend Files:**

- `apps/web/src/components/spot/SpotDetailCard.tsx` - use SpotAddress
- `apps/web/src/components/spot/SpotListItem.tsx` - show address

### Testing Coverage

- reverseGeocode: 100%
- findByCoords: 100%
- SpotAddress: 95%
- Async flow: 90%

## Change Log

| Date       | Version | Description            | Author |
| ---------- | ------- | ---------------------- | ------ |
| 2026-01-15 | 1.0     | Initial story creation | PO     |
